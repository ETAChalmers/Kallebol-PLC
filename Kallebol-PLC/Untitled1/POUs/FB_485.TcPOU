<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_485" Id="{48e89cc4-5645-4050-9504-631b442f96a5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_485
//This functionblock is suposed to handle the 485 comminication
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	
	Timer : TON;
	//timer2 : TON;
	Send: SendData; //Functionblock of TC2_SerialCom
	SendBusy: BOOL; // copy of SendData.Busy
	SendErrorID: ComError_t;
	aDataTx: tDataFrame;
	Receive: ReceiveData;
	LastReceivedDataBytes: tDataFrame;
	DataReceived: BOOL;
	ReceiveBusy: BOOL;
	ReceiveErrorID: ComError_t;
	ReceiveTimeout: BOOL;
	ReceiveCounter: UDINT :=0;	
	aDataRx: tDataFrame;
	nDataLen: BYTE := 9;
	bNodeId_SL1: BYTE := 1; //Slave one Serial ID
	nState: INT;
	nRxChecksum: BYTE;
	nCalcChecksum: BYTE;
	T_ReceiveDelay:TIME;
	
	//Used as a intermediate step to transmit/recive
	RXcombuffer : combuffer;
	TXcombuffer : combuffer;
	Combuffersize : UINT := 301;//0..300 so 301 values //Defined by combuffer
	
	RegisterRequested : BOOL := FALSE;
	AxisParameterRequested : BOOL := FALSE;

	i: UINT;
END_VAR
VAR CONSTANT
	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="DataRequestHandler" Id="{ef849b15-89bc-48c1-b22c-40eb35ef5bad}">
      <Declaration><![CDATA[METHOD DataRequestHandler : BOOL
VAR_INPUT
END_VAR
VAR
	payload : DWORD;
	Module : BYTE;
	Fcode : BYTE;
	msg_len : BYTE;
	Command : BYTE;
	i : BYTE;
	Checksum: UINT;
	Checksum_rec : UINT;
	REQ_data : ARRAY[0 .. 8] OF BYTE;
	last_issued_get_index : UINT;
END_VAR


]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF RXcombuffer.Count > 1 THEN
	
	//This is done instead of a memcpy as RXcombuffer is a ringbuffer and the loopover is scary
	//Debug data mainly
	REQ_data[0] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+0) MOD Combuffersize];
	REQ_data[1] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+1) MOD Combuffersize];
	REQ_data[2] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+2) MOD Combuffersize];
	REQ_data[3] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+3) MOD Combuffersize];
	REQ_data[4] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+4) MOD Combuffersize];
	REQ_data[5] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+5) MOD Combuffersize];
	REQ_data[6] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+6) MOD Combuffersize];
	REQ_data[7] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+7) MOD Combuffersize];
	REQ_data[8] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+8) MOD Combuffersize];
	REQ_data[9] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+9) MOD Combuffersize];
	REQ_data[10] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+10) MOD Combuffersize];
	REQ_data[11] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+11) MOD Combuffersize];
	REQ_data[12] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+12) MOD Combuffersize];
	REQ_data[13] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+13) MOD Combuffersize];
	
//	last_issued_get_index := (TXcombuffer.WrIdx-6 MOD Combuffersize); //Should uilize aTX buffer instead
	
	Module  := RXcombuffer.Buffer[(RXcombuffer.RdIdx+1) MOD Combuffersize]; //Adress
	Fcode  := RXcombuffer.Buffer[(RXcombuffer.RdIdx+2) MOD Combuffersize]; // Function code
	msg_len := RXcombuffer.Buffer[(RXcombuffer.RdIdx+3) MOD Combuffersize]; //Byte length, of data, not including CRC and header
	
	//Cecksum is 16-bit, combine two bytes( 4+msg_len )
	Checksum_rec := payload := (RXcombuffer.Buffer[RXcombuffer.RdIdx+( 5+msg_len ) MOD Combuffersize] 
	OR SHR(BYTE_TO_DWORD(RXcombuffer.Buffer[(RXcombuffer.RdIdx+( 4+msg_len )) MOD Combuffersize]),8));
	
	//Checksum := RXcombuffer.Buffer[(RXcombuffer.RdIdx) MOD Combuffersize];
	//FOR i := 1 TO 7 DO
	//	Checksum := Checksum + RXcombuffer.Buffer[(RXcombuffer.RdIdx+i) MOD Combuffersize];
	//END_FOR
	
	//IF Checksum = Checksum_rec THEN
		//If the checksum is correct
	
		CASE Fcode OF

			3: //Return data of angle
			IF RegisterRequested THEN
				RegisterRequested := FALSE;
				payload := (RXcombuffer.Buffer[RXcombuffer.RdIdx+7 MOD Combuffersize] 
				OR SHR(BYTE_TO_DWORD(RXcombuffer.Buffer[(RXcombuffer.RdIdx+6) MOD Combuffersize]),8) 
				OR SHR(BYTE_TO_DWORD(RXcombuffer.Buffer[(RXcombuffer.RdIdx+5) MOD Combuffersize]),16) 
				OR SHR(BYTE_TO_DWORD(RXcombuffer.Buffer[(RXcombuffer.RdIdx+4) MOD Combuffersize]),24));

			END_IF
			
		END_CASE
	//ELSE
	//	//Invalid checksum
	//	ADSLOGSTR(msgCtrlMask:=ADSLOG_MSGTYPE_ERROR,msgFmtStr:='Got an invalid RS485 checksum in DataRequestHandler',strArg:='');
	//END_IF
	
	RXcombuffer.Count := RXcombuffer.Count - nDataLen;
	RXcombuffer.RdIdx := ((RXcombuffer.RdIdx + nDataLen)  MOD Combuffersize);
	RXcombuffer.FreeByte := RXcombuffer.FreeByte + nDataLen;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="fb_init" Id="{1a642bab-641a-442d-8557-a6d0157ed78e}">
      <Declaration><![CDATA[METHOD fb_init : BOOL
VAR_INPUT
	bInitRetains : BOOL;
	bInCopyCode : BOOL;
END_VAR

VAR
	i: BYTE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//PD1140 : ARRAY[1..3] OF TMCL_Motor;

FOR i := 1 TO nMotors DO
	PD1140[i].MotorID := i;
	RequestedPos[i] := 0;
END_FOR
PD1140[1].Offset := 0;
PD1140[2].Offset := 0;
PD1140[3].Offset := PD1140[2].Offset;]]></ST>
      </Implementation>
    </Method>
    <Method Name="RequestAxisParameter" Id="{bfd5b97a-6326-4632-aa0c-3b354a8ed501}">
      <Declaration><![CDATA[METHOD RequestAxisParameter : BOOL
VAR_INPUT
	MotorID : BYTE;
	InstType : BYTE;
	Bank : BYTE;
END_VAR
VAR
	aDataTx: tDataFrame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL.TxBuffer_MASTER.Count < 1 THEN //No other commands in the buffer, so add this
							//This is done to maintain priority for the wirefeed stuff and try to remove artifacts from reading

	AxisParameterRequested := TRUE; // This ties in with the DataRequestHandler
	aDataTX[0] := MotorID;
	aDataTX[1] := 6; 
	aDataTX[2] := InstType;
	aDataTX[3] := Bank;
	//DATA
	
	aDataTX[7] := 0;
	aDataTX[6] := 0;
	aDataTX[5] := 0;
	aDataTX[4] := 0;
	
	aDataTX[8] := 0; //Checksum is calcuated on transmit
	Transmit(dataIn := aDataTX);
	RequestAxisParameter := TRUE;
ELSE
	//The buffer has something in it, and nothing was sent
 	RequestAxisParameter := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SendCycle" Id="{30ca481c-e77c-4d4f-9d77-2515433a2beb}">
      <Declaration><![CDATA[METHOD SendCycle : BOOL
VAR_INPUT
END_VAR

VAR

	i: UINT;
	
	Checksum: WORD;
	Trans_delay : TIME := LREAL_TO_TIME(nDataLen * (1/DINT_TO_LREAL(nSetBaudrate))*33*1000);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE nState OF
0:

timer(IN:=TRUE,PT:=Trans_delay);
IF Timer.Q THEN
	IF TXcombuffer.Count > 1 THEN
		
		//Extract a datapackage from the ringbuffer	
		IF TXcombuffer.RdIdx + nDataLen >= Combuffersize THEN
			//If the buffer loops around the edge
			FOR i := 0 TO nDataLen-1 DO
				aDataTX[i] := TXcombuffer.buffer[((TXcombuffer.RdIdx + i) MOD Combuffersize)];

			END_FOR
			TXcombuffer.Count := TXcombuffer.Count - nDataLen;
			TXcombuffer.FreeByte := TXcombuffer.FreeByte + nDataLen;
			TXcombuffer.RdIdx := ((TXcombuffer.RdIdx + nDataLen ) MOD Combuffersize);
		ELSE
			//Normal operation of the buffer
			memcpy(destAddr:=ADR(aDataTX), srcAddr:=ADR(TXcombuffer.buffer[TXcombuffer.RdIdx]) , nDataLen);
			TXcombuffer.Count := TXcombuffer.Count - nDataLen;
			TXcombuffer.RdIdx := ((TXcombuffer.RdIdx + nDataLen ) MOD Combuffersize);
			TXcombuffer.FreeByte := TXcombuffer.FreeByte + nDataLen;
		END_IF
		
		
		//Calculate checksum
		Checksum := aDataTX[0];
		FOR i := 1 TO 7 DO
			Checksum := Checksum + aDataTX[i];
		END_FOR
		//Checksum := Checksum MOD 255; //Potential unnecicary row
		aDataTX[8] := WORD_TO_BYTE(Checksum); //Overwrites the inputted checksum
		
		Send(pSendData:=ADR(aDataTX),Length :=nDataLen,
			TXbuffer:=TxBuffer_MASTER,
			Busy =>SendBusy, Error => SendErrorID);
		Timer(IN:=FALSE);
		IF NOT SendBusy THEN
			nState := nState+1;
		END_IF
	END_IF
END_IF

1:

	//T_ReceiveDelay := nDataLen *REAL_TO_TIME((1/DINT_TO_REAL(nSetBaudrate))*33*1000);
	timer(IN:=TRUE,PT:=Trans_delay);
	IF Timer.Q THEN
		nState:= nState+1;
		Timer(IN:=FALSE);
	END_IF
	
2:

Receive(
pReceiveData :=ADR(aDataRX[0]),
SizeReceiveData:= (nDataLen),
RXbuffer:= RxBuffer_MASTER,
Timeout:=T#1S,
DataReceived=>DataReceived,
busy => receiveBusy,
Error => ReceiveErrorID,
RxTimeout =>ReceiveTimeout);

IF DataReceived THEN
	IF NOT ReceiveBusy THEN
		nRxChecksum := aDataRX[nDataLen-1];
		
		Checksum := aDataRX[0];
		FOR i := 1 TO nDataLen-2 DO
			Checksum := Checksum + aDataRX[i];
		END_FOR
		//Checksum := Checksum MOD 255; //Potential unnecicary row
		nCalcChecksum := WORD_TO_BYTE(Checksum); //Overwrites the inputted checksum
		
		IF(nRXChecksum = nCalcChecksum) THEN
			IF RXcombuffer.WrIdx + nDataLen >= Combuffersize THEN
				//Loop around write
				FOR i := 0 TO nDataLen-1 DO
					RXcombuffer.buffer[((RXcombuffer.WrIdx + i) MOD Combuffersize)] := aDataRX[i];
				END_FOR
				RXcombuffer.Count := RXcombuffer.Count + nDataLen;
				RXcombuffer.FreeByte := RXcombuffer.FreeByte - nDataLen;
				RXcombuffer.WrIdx := ((RXcombuffer.WrIdx + nDataLen) MOD Combuffersize);
				
			ELSE	
				//Normal operation of the buffer
				memcpy( destAddr:=ADR(RXcombuffer.buffer[RXcombuffer.WrIdx]) , srcAddr:=ADR(aDataRX) , nDataLen);
				RXcombuffer.WrIdx := ((RXcombuffer.WrIdx + nDataLen) MOD Combuffersize);
				RXcombuffer.Count := RXcombuffer.Count + nDataLen;
				RXcombuffer.FreeByte := TXcombuffer.FreeByte - nDataLen;
			END_IF
		END_IF
		nState := 0;
	END_IF
	ELSE
		Timer(IN:=TRUE,PT:=T#50MS);
		IF Timer.Q THEN //Timeout
			nState := 0;
			RXcombuffer.WrIdx := ((RXcombuffer.WrIdx + nDataLen) MOD Combuffersize);
			RXcombuffer.FreeByte := TXcombuffer.FreeByte - nDataLen;
			RXcombuffer.Count := RXcombuffer.Count + nDataLen;
		END_IF
	END_IF
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetAxisParameter" Id="{fd2cae3c-893b-4399-b183-6dc0a8c9ca88}">
      <Declaration><![CDATA[METHOD SetAxisParameter : BOOL
VAR_INPUT
	MotorID : BYTE;
	InstType : BYTE;
	Bank : BYTE;
	data : DINT;
END_VAR
VAR
	aDataTx: tDataFrame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
aDataTX[0] := MotorID;
aDataTX[1] := 5; //SAP set axis parameter 
aDataTX[2] := InstType;
aDataTX[3] := Bank;
//DATA

aDataTX[7] := DINT_TO_BYTE(data);
data := SHR(data,8);
aDataTX[6] := DINT_TO_BYTE(data);
data := SHR(data,8);
aDataTX[5] := DINT_TO_BYTE(data);
data := SHR(data,8);
aDataTX[4] := DINT_TO_BYTE(data);

aDataTX[8] := 0; //Checksum is calcuated on transmit
Transmit(dataIn := aDataTX);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Transmit" Id="{786599fc-9d6f-4e48-9180-c7e25a91346b}">
      <Declaration><![CDATA[METHOD Transmit : INT
VAR_INPUT
	dataIn : tDataFrame;
END_VAR

VAR
	i: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Add data to the end of the transmit buffer
IF TXcombuffer.Count >= Combuffersize - nDataLen THEN
	TXcombuffer.Error := INT_TO_UINT(ComError_t.COMERROR_TXBUFFOVERRUN);
	Transmit := ComError_t.COMERROR_TXBUFFOVERRUN;
ELSE
	Transmit := ComError_t.COMERROR_NOERROR;
	TXcombuffer.Error := INT_TO_UINT(ComError_t.COMERROR_NOERROR);
	
	IF TXcombuffer.WrIdx + nDataLen >= Combuffersize THEN
		//Loop around write
		FOR i := 0 TO nDataLen-1 DO
			TXcombuffer.buffer[((TXcombuffer.WrIdx + i) MOD Combuffersize)] := dataIn[i];
		END_FOR
		TXcombuffer.WrIdx := ((TXcombuffer.WrIdx + nDataLen) MOD Combuffersize);
		TXcombuffer.Count := TXcombuffer.Count + nDataLen;
		TXcombuffer.FreeByte := TXcombuffer.FreeByte - nDataLen;
				
	ELSE	
		//Normal operation of the buffer
		memcpy( destAddr:=ADR(TXcombuffer.buffer[TXcombuffer.WrIdx]) , srcAddr:=ADR(dataIn) , nDataLen);
		TXcombuffer.Count := TXcombuffer.Count + nDataLen;
		TXcombuffer.WrIdx := ((TXcombuffer.WrIdx + nDataLen) MOD Combuffersize);
		TXcombuffer.FreeByte := TXcombuffer.FreeByte - nDataLen;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="update" Id="{f142b844-dadf-4ffe-8c53-b088502a94ea}">
      <Declaration><![CDATA[METHOD update : BOOL
VAR_INPUT
END_VAR
VAR

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SendCycle();
DataRequestHandler();
//X := LREAL_TO_REAL(PD1140[1].GetPosition()*gearing-PD1140[1].Offset);
//Y := LREAL_TO_REAL(PD1140[2].GetPosition()*gearing-PD1140[2].Offset);
//Z := LREAL_TO_REAL(PD1140[3].GetPosition()*gearing-PD1140[3].Offset);
//
//X_temp := PD1140[1].Temperature;
//Y_temp := PD1140[2].Temperature;
//Z_temp := PD1140[3].Temperature;
WF_temp := PD1140[4].Temperature;
WF_current := PD1140[4].CurrentDraw;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Update_TMCL_wirefeeder" Id="{9d5c7050-1757-4cc8-bdb4-1a578befec70}">
      <Declaration><![CDATA[METHOD Update_TMCL_wirefeeder : BOOL
VAR_INPUT

END_VAR

VAR CONSTANT
	ID: BYTE := 4; //ID of the wiremotor
	
	Wheel_diameter : REAL := 22.45; //Adjusted after measuring a meter 22.79; // diameter of the feedwheel in mm //Outside diameter is 23.0, groove bottom is 22.7
	wire_diameter : REAL := 0.8; // in mm, Only used to calculate mass-flow
	gearing : LREAL := 12.5;//6.25;//12.5; // 12.5 rotations on the axle gives one roation of the wheel
END_VAR


VAR
	Setpoint_RPM : LREAL := 0;
	
	Dir : BOOL;
	SpeedError : BOOL := FALSE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Calculate the speed of the motor from feedrate
SpeedError := FALSE;
_Speed := 0;
IF(WireFeedrate > 0) THEN
	Dir := TRUE;
ELSIF(WireFeedrate <0) THEN
	DIR:= FALSE;
END_IF

//Feedrates uint is [mm/s]
Setpoint_RPM := ((ABS(WireFeedrate) * 60 * gearing) / (Wheel_diameter*3.1415));
_Speed := PD1140[4].CONVERT_RPM_TO_INTSPEED(Setpoint_RPM);


IF(_Speed > 2047) THEN
	_speed := 2047;
	SpeedError := TRUE;
ELSIF(_Speed < 0) THEN
	_Speed := 0;
	SpeedError := TRUE;
END_IF


IF (NOT (PD1140[ID].GetSpeed() = _Speed)) THEN //If a speedchange is neccesarry
	
	//Declare the direction of rotoation
	IF   (_Speed > 0) THEN
		RotateMotor(Speed := _Speed, MotorID := ID,Direction := Dir);
	ELSIF(_Speed = 0) THEN
		StopMotor(ID);
	END_IF
	PD1140[ID].SetSpeed(_Speed);

END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_485">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.DataRequestHandler">
      <LineId Id="3" Count="12" />
      <LineId Id="94" Count="4" />
      <LineId Id="16" Count="5" />
      <LineId Id="92" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="24" Count="15" />
      <LineId Id="45" Count="2" />
      <LineId Id="66" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.fb_init">
      <LineId Id="3" Count="7" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.RequestAxisParameter">
      <LineId Id="3" Count="21" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.SendCycle">
      <LineId Id="3" Count="105" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.SetAxisParameter">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.Transmit">
      <LineId Id="3" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.update">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.Update_TMCL_wirefeeder">
      <LineId Id="3" Count="32" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>