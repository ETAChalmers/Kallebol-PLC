<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_485" Id="{48e89cc4-5645-4050-9504-631b442f96a5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_485
//This functionblock is suposed to handle the 485 comminication
//Call Update cyclicly to push data to TX buffert and read data from the TX bufferts
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	
	Timer : TON;
	//timer2 : TON;
	Send: SendData; //Functionblock of TC2_SerialCom
	SendBusy: BOOL; // copy of SendData.Busy
	SendErrorID: ComError_t;
	aDataTx: tDataFrame;
	Receive: ReceiveData;
	LastReceivedDataBytes: tDataFrame;
	DataReceived: BOOL;
	ReceiveBusy: BOOL;
	ReceiveErrorID: ComError_t;
	ReceiveTimeout: BOOL;
	ReceiveCounter: UDINT :=0;	
	aDataRx: tDataFrame;
	nDataLen: BYTE := 9;
	bNodeId_SL1: BYTE := 1; //Slave one Serial ID
	nState: INT;
	nRxChecksum: BYTE;
	nCalcChecksum: BYTE;
	T_ReceiveDelay:TIME;
	
	//Used as a intermediate step to transmit/recive
	RXcombuffer : combuffer;
	TXcombuffer : combuffer;
	Combuffersize : UINT := 301;//0..300 so 301 values //Defined by combuffer
	
	RegisterRequested : BOOL := FALSE;
	AxisParameterRequested : BOOL := FALSE;

	i: UINT;
END_VAR
VAR CONSTANT
	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="DataRequestHandler" Id="{ef849b15-89bc-48c1-b22c-40eb35ef5bad}">
      <Declaration><![CDATA[METHOD DataRequestHandler : BOOL
VAR_INPUT
END_VAR
VAR
	payload : DWORD;
	payload_DINT : DINT;
	Module : BYTE;
	Fcode : BYTE;
	msg_len : BYTE;
	Command : BYTE;
	i : BYTE;
	Checksum: UINT;
	Checksum_rec : DWORD;
	REQ_data : ARRAY[0 .. 13] OF BYTE;
	last_issued_get_index : UINT;
	
END_VAR


]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF RXcombuffer.Count > 1 THEN
	
	//This is done instead of a memcpy as RXcombuffer is a ringbuffer and the loopover is scary
	//Debug data mainly
	REQ_data[0] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+0) MOD Combuffersize];
	REQ_data[1] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+1) MOD Combuffersize];
	REQ_data[2] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+2) MOD Combuffersize];
	REQ_data[3] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+3) MOD Combuffersize];
	REQ_data[4] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+4) MOD Combuffersize];
	REQ_data[5] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+5) MOD Combuffersize];
	REQ_data[6] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+6) MOD Combuffersize];
	REQ_data[7] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+7) MOD Combuffersize];
	REQ_data[8] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+8) MOD Combuffersize];
	REQ_data[9] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+9) MOD Combuffersize];
	REQ_data[10] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+10) MOD Combuffersize];
	REQ_data[11] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+11) MOD Combuffersize];
	REQ_data[12] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+12) MOD Combuffersize];
	REQ_data[13] := RXcombuffer.Buffer[(RXcombuffer.RdIdx+13) MOD Combuffersize];
	
//	last_issued_get_index := (TXcombuffer.WrIdx-6 MOD Combuffersize); //Should uilize aTX buffer instead
	
	Module  := RXcombuffer.Buffer[(RXcombuffer.RdIdx+1) MOD Combuffersize]; //Adress
	Fcode  := RXcombuffer.Buffer[(RXcombuffer.RdIdx+2) MOD Combuffersize]; // Function code
	msg_len := RXcombuffer.Buffer[(RXcombuffer.RdIdx+3) MOD Combuffersize]; //Byte length, of data, not including CRC and header
	
	//Checksum is 16-bit, combine two bytes( 4+msg_len )
	Checksum_rec := payload := (RXcombuffer.Buffer[RXcombuffer.RdIdx+( 5+msg_len ) MOD Combuffersize] 
	OR SHR(BYTE_TO_DWORD(RXcombuffer.Buffer[(RXcombuffer.RdIdx+( 4+msg_len )) MOD Combuffersize]),8));
	
	//Just ignore the checksum for now
	//Checksum := RXcombuffer.Buffer[(RXcombuffer.RdIdx) MOD Combuffersize];
	//FOR i := 1 TO 7 DO
	//	Checksum := Checksum + RXcombuffer.Buffer[(RXcombuffer.RdIdx+i) MOD Combuffersize];
	//END_FOR
	
	//IF Checksum = Checksum_rec THEN
		//If the checksum is correct
	
		CASE Fcode OF

			3: //Return data of angle
			IF RegisterRequested THEN
				RegisterRequested := FALSE;
				payload := (RXcombuffer.Buffer[RXcombuffer.RdIdx+7 MOD Combuffersize] 
				OR SHR(BYTE_TO_DWORD(RXcombuffer.Buffer[(RXcombuffer.RdIdx+6) MOD Combuffersize]),8) 
				OR SHR(BYTE_TO_DWORD(RXcombuffer.Buffer[(RXcombuffer.RdIdx+5) MOD Combuffersize]),16) 
				OR SHR(BYTE_TO_DWORD(RXcombuffer.Buffer[(RXcombuffer.RdIdx+4) MOD Combuffersize]),24));
				
				memcpy(ADR(payload_DINT),ADR(payload),4); 
				//Because the Payload is a DWORD and we need to cast it to a 
				//INT 
				
				MAIN.Elevation.set_Current_Position_deg(DINT_TO_LREAL(payload_DINT)/1000);
			END_IF
			
		END_CASE
	//ELSE
	//	//Invalid checksum
	//	ADSLOGSTR(msgCtrlMask:=ADSLOG_MSGTYPE_ERROR,msgFmtStr:='Got an invalid RS485 checksum in DataRequestHandler',strArg:='');
	//END_IF
	
	RXcombuffer.Count := RXcombuffer.Count - nDataLen;
	RXcombuffer.RdIdx := ((RXcombuffer.RdIdx + nDataLen)  MOD Combuffersize);
	RXcombuffer.FreeByte := RXcombuffer.FreeByte + nDataLen;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="fb_init" Id="{1a642bab-641a-442d-8557-a6d0157ed78e}">
      <Declaration><![CDATA[METHOD fb_init : BOOL
VAR_INPUT
	bInitRetains : BOOL;
	bInCopyCode : BOOL;
END_VAR

VAR
	i: BYTE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="Request_RS485_angles" Id="{46bc118a-9edb-438c-9efb-c5ffd2fbcc11}">
      <Declaration><![CDATA[METHOD Request_RS485_angles : BOOL
//Create a request block and add to the transmit list for getting the angles of the
//Angle sensor
//https://www.leveldevelopments.com/wp/wp-content/uploads/documents/How2_SOLARMOD.pdf

VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL.TxBuffer_MASTER.Count < 1 THEN //No other commands in the buffer, so add this
							//This is done to maintain priority for the wirefeed stuff and try to remove artifacts from reading

	AxisParameterRequested := TRUE; // This ties in with the DataRequestHandler
	aDataTX[0] := 64; //Adress
	aDataTX[1] := 3;  //Function code //3 = READ
	aDataTX[2] := 0;  //Start adress to read
	aDataTX[3] := 0;  //Start adress to read
	aDataTX[4] := 0;  //Number of bytes to read
	aDataTX[5] := 2;  //Number of bytes to read
	aDataTX[6] := 16#CD;  //CRC
	aDataTX[7] := 16#FE;  //CRC

	//CRC calculation is not implemented as it is right now,
	//Probably wont be needed for this project 
	
	Transmit(dataIn := aDataTX, numBytes := 8);
ELSE
	//The buffer has something in it, and nothing was sent
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SendCycle" Id="{30ca481c-e77c-4d4f-9d77-2515433a2beb}">
      <Declaration><![CDATA[METHOD SendCycle : BOOL
VAR_INPUT
END_VAR

VAR

	i: UINT;
	
	Checksum: WORD;
	Trans_delay : TIME := LREAL_TO_TIME(nDataLen * (1/DINT_TO_LREAL(GVL.nSetBaudrate))*33*1000);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE nState OF
0:

timer(IN:=TRUE,PT:=Trans_delay);
IF Timer.Q THEN
	IF TXcombuffer.Count > 1 THEN
		
		//Extract a datapackage from the ringbuffer	
		IF TXcombuffer.RdIdx + nDataLen >= Combuffersize THEN
			//If the buffer loops around the edge
			FOR i := 0 TO nDataLen-1 DO
				aDataTX[i] := TXcombuffer.buffer[((TXcombuffer.RdIdx + i) MOD Combuffersize)];

			END_FOR
			TXcombuffer.Count := TXcombuffer.Count - nDataLen;
			TXcombuffer.FreeByte := TXcombuffer.FreeByte + nDataLen;
			TXcombuffer.RdIdx := ((TXcombuffer.RdIdx + nDataLen ) MOD Combuffersize);
		ELSE
			//Normal operation of the buffer
			memcpy(destAddr:=ADR(aDataTX), srcAddr:=ADR(TXcombuffer.buffer[TXcombuffer.RdIdx]) , nDataLen);
			TXcombuffer.Count := TXcombuffer.Count - nDataLen;
			TXcombuffer.RdIdx := ((TXcombuffer.RdIdx + nDataLen ) MOD Combuffersize);
			TXcombuffer.FreeByte := TXcombuffer.FreeByte + nDataLen;
		END_IF
		
		
		//Calculate checksum
		Checksum := aDataTX[0];
		FOR i := 1 TO 7 DO
			Checksum := Checksum + aDataTX[i];
		END_FOR
		//Checksum := Checksum MOD 255; //Potential unnecicary row
		aDataTX[8] := WORD_TO_BYTE(Checksum); //Overwrites the inputted checksum
		
		Send(pSendData:=ADR(aDataTX),Length :=nDataLen,
			TXbuffer:=GVL.TxBuffer_MASTER,
			Busy =>SendBusy, Error => SendErrorID);
		Timer(IN:=FALSE);
		IF NOT SendBusy THEN
			nState := nState+1;
		END_IF
	END_IF
END_IF

1:

	//T_ReceiveDelay := nDataLen *REAL_TO_TIME((1/DINT_TO_REAL(nSetBaudrate))*33*1000);
	timer(IN:=TRUE,PT:=Trans_delay);
	IF Timer.Q THEN
		nState:= nState+1;
		Timer(IN:=FALSE);
	END_IF
	
2:

Receive(
pReceiveData :=ADR(aDataRX[0]),
SizeReceiveData:= (nDataLen),
RXbuffer:= GVL.RxBuffer_MASTER,
Timeout:=T#1S,
DataReceived=>DataReceived,
busy => receiveBusy,
Error => ReceiveErrorID,
RxTimeout =>ReceiveTimeout);

IF DataReceived THEN
	IF NOT ReceiveBusy THEN
		nRxChecksum := aDataRX[nDataLen-1];
		
		Checksum := aDataRX[0];
		FOR i := 1 TO nDataLen-2 DO
			Checksum := Checksum + aDataRX[i];
		END_FOR
		//Checksum := Checksum MOD 255; //Potential unnecicary row
		nCalcChecksum := WORD_TO_BYTE(Checksum); //Overwrites the inputted checksum
		
		IF(nRXChecksum = nCalcChecksum) THEN
			IF RXcombuffer.WrIdx + nDataLen >= Combuffersize THEN
				//Loop around write
				FOR i := 0 TO nDataLen-1 DO
					RXcombuffer.buffer[((RXcombuffer.WrIdx + i) MOD Combuffersize)] := aDataRX[i];
				END_FOR
				RXcombuffer.Count := RXcombuffer.Count + nDataLen;
				RXcombuffer.FreeByte := RXcombuffer.FreeByte - nDataLen;
				RXcombuffer.WrIdx := ((RXcombuffer.WrIdx + nDataLen) MOD Combuffersize);
				
			ELSE	
				//Normal operation of the buffer
				memcpy( destAddr:=ADR(RXcombuffer.buffer[RXcombuffer.WrIdx]) , srcAddr:=ADR(aDataRX) , nDataLen);
				RXcombuffer.WrIdx := ((RXcombuffer.WrIdx + nDataLen) MOD Combuffersize);
				RXcombuffer.Count := RXcombuffer.Count + nDataLen;
				RXcombuffer.FreeByte := TXcombuffer.FreeByte - nDataLen;
			END_IF
		END_IF
		nState := 0;
	END_IF
	ELSE
		Timer(IN:=TRUE,PT:=T#50MS);
		IF Timer.Q THEN //Timeout
			nState := 0;
			RXcombuffer.WrIdx := ((RXcombuffer.WrIdx + nDataLen) MOD Combuffersize);
			RXcombuffer.FreeByte := TXcombuffer.FreeByte - nDataLen;
			RXcombuffer.Count := RXcombuffer.Count + nDataLen;
		END_IF
	END_IF
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Transmit" Id="{786599fc-9d6f-4e48-9180-c7e25a91346b}">
      <Declaration><![CDATA[METHOD Transmit : INT
VAR_INPUT
	dataIn : tDataFrame;
	numBytes : BYTE;
END_VAR

VAR
	i: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Add data to the end of the transmit buffer
IF TXcombuffer.Count >= Combuffersize - numBytes THEN
	TXcombuffer.Error := INT_TO_UINT(ComError_t.COMERROR_TXBUFFOVERRUN);
	Transmit := ComError_t.COMERROR_TXBUFFOVERRUN;
ELSE
	Transmit := ComError_t.COMERROR_NOERROR;
	TXcombuffer.Error := INT_TO_UINT(ComError_t.COMERROR_NOERROR);
	
	IF TXcombuffer.WrIdx + numBytes >= Combuffersize THEN
		//Loop around write
		FOR i := 0 TO numBytes-1 DO
			TXcombuffer.buffer[((TXcombuffer.WrIdx + i) MOD Combuffersize)] := dataIn[i];
		END_FOR
		TXcombuffer.WrIdx := ((TXcombuffer.WrIdx + numBytes) MOD Combuffersize);
		TXcombuffer.Count := TXcombuffer.Count + numBytes;
		TXcombuffer.FreeByte := TXcombuffer.FreeByte - numBytes;
				
	ELSE	
		//Normal operation of the buffer
		memcpy( destAddr:=ADR(TXcombuffer.buffer[TXcombuffer.WrIdx]) , srcAddr:=ADR(dataIn) , numBytes);
		TXcombuffer.Count := TXcombuffer.Count + numBytes;
		TXcombuffer.WrIdx := ((TXcombuffer.WrIdx + numBytes) MOD Combuffersize);
		TXcombuffer.FreeByte := TXcombuffer.FreeByte - numBytes;
	END_IF
END_IF



]]></ST>
      </Implementation>
    </Method>
    <Method Name="update" Id="{f142b844-dadf-4ffe-8c53-b088502a94ea}">
      <Declaration><![CDATA[METHOD update : BOOL
VAR_INPUT
END_VAR
VAR

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SendCycle();
DataRequestHandler();


]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_485">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.DataRequestHandler">
      <LineId Id="3" Count="12" />
      <LineId Id="94" Count="4" />
      <LineId Id="16" Count="5" />
      <LineId Id="92" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="24" Count="15" />
      <LineId Id="45" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="126" Count="1" />
      <LineId Id="125" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="46" Count="1" />
      <LineId Id="66" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.fb_init">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.Request_RS485_angles">
      <LineId Id="13" Count="8" />
      <LineId Id="35" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.SendCycle">
      <LineId Id="3" Count="105" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.Transmit">
      <LineId Id="3" Count="23" />
      <LineId Id="2" Count="0" />
      <LineId Id="36" Count="2" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="FB_485.update">
      <LineId Id="3" Count="1" />
      <LineId Id="13" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>